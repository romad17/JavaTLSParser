<!DOCTYPE HTML>
<html lang="en">
<head>
	<script src="pako.js"></script>
	<style>
		th {
			text-align: center;
			border: 1px solid white;
		}

		td {
			border: 1px solid white;
			word-wrap: break-word;
		}

		table {
			table-layout: fixed;
			width: 100%;
			border: 1px solid white;
			border-collapse: collapse;
			font-family: monospace;
			padding: 2px;
		}
</style>
	<title>Java TLS Debug Log Parser</title>
</head> 

<body style = "text-align:left;background-color:#202020;color:white;" id = "body"> 
<div style="text-align: center;">
	<div id="space"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div>
	<h3>Load your log file:</h3>
	<label for="thread-input">Thread name to decode (ex. sub-scan-0):</label><input id="thread-input"
																					name="thread-input" type="text"><br><br>
	<input id="file-input" type="file"/></div>
<div id="file-content"><p id="afterend"></p></div>
<!-- <pre id="file-content"></pre> -->

<script>

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
    hexes_array=[
	];
    let dec_array=[];

    for (let hx = 0; hx < hexes_array.length; hx++) {
        dec_array = dec_array.concat(parseInt(hexes_array[hx], 16));
    }

    console.log('dec_array.length: ' + dec_array.length);
    console.log("dec_array: " + dec_array);

    //to_inflate = new Uint8Array(dec_array);
    //console.log('to_inflate.length: ' + to_inflate.length);
    //console.log('to_inflate: ' + to_inflate);

    try {
        inflated = pako.inflate(dec_array);
    }
    catch (err) {
        console.error(err);
    }
    decoded = new TextDecoder().decode(inflated);
    console.log('inflated: ' + inflated);
    console.log('decoded: ' + decoded);

*/
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function myFunction(col) {
		// Declare variables
		let input, filter, table, tr, td, i, txtValue;
		input = document.getElementById("myInput" + col);
		filter = input.value.toUpperCase();
		table = document.getElementById("myTable");
		tr = table.getElementsByTagName("tr");

		// Loop through all table rows, and hide those who don't match the search query
		for (i = 0; i < tr.length; i++) {
			td = tr[i].getElementsByTagName("td")[col];
			if (td) {
				txtValue = td.textContent || td.innerText;
				if (txtValue.toUpperCase().indexOf(filter) > -1) {
					tr[i].style.display = "";
				} else {
					tr[i].style.display = "none";
				}
			}
		}
	}

	function sortTable(col) {
	let table, rows, switching, i, x, y, shouldSwitch;
	table = document.getElementById("myTable");
  switching = true;
  /*Make a loop that will continue until
  no switching has been done:*/
  while (switching) {
    //start by saying: no switching is done:
    switching = false;
    rows = table.rows;
    /*Loop through all table rows (except the first, which contains table headers):*/
    for (i = 1; i < (rows.length - 1); i++) {
      //start by saying there should be no switching:
      shouldSwitch = false;
      /*Get the two elements you want to compare, one from current row and one from the next:*/
      x = rows[i].getElementsByTagName("TD")[col];
      y = rows[i + 1].getElementsByTagName("TD")[col];
      //check if the two rows should switch place:
      if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
        //if so, mark as a switch and break the loop:
        shouldSwitch = true;
        break;
      }
    }
    if (shouldSwitch) {
      /*If a switch has been marked, make the switch
      and mark that a switch has been done:*/
      rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
      switching = true;
    }
  }
}

	function readSingleFile(e) {
	const file = e.target.files[0];
	if (!file) {return;}
	const reader = new FileReader();
	reader.onload = function(e) {
		const contents = e.target.result.split('\n');
		displayContents(contents);
	};
	reader.readAsText(file);
}

	function displayContents(lines) {
		document.getElementById('space').style.display = "none";
		const element = document.getElementById('file-content');
		let out = '<table id="myTable">\
					<thead>\
						<tr>\
							<th style="width:200px">Time      <br><button onclick="sortTable(0)">Sort</button><br><input type="text" id="myInput0" onkeyup="myFunction(0)" placeholder="Filter" style="width:180px"></th>\
							<th style="width:200px">Thread    <br><button onclick="sortTable(1)">Sort</button><br><input type="text" id="myInput1" onkeyup="myFunction(1)" placeholder="Filter" style="width:180px"></th>\
							<th style="width:50px" >Thrd_ID   <br><button onclick="sortTable(2)">Sort</button><br><input type="text" id="myInput2" onkeyup="myFunction(2)" placeholder="Filter" style="width:40px"></th>\
							<th style="width:50px" >Level     <br><button onclick="sortTable(3)">Sort</button><br><input type="text" id="myInput3" onkeyup="myFunction(3)" placeholder="Filter" style="width:40px"></th>\
							<th style="width:60px" >I/O       <br><button onclick="sortTable(4)">Sort</button><br><input type="text" id="myInput4" onkeyup="myFunction(4)" placeholder="Filter" style="width:50px"></th>\
							<th style="width:200px">Host      <br><button onclick="sortTable(5)">Sort</button><br><input type="text" id="myInput5" onkeyup="myFunction(5)" placeholder="Filter" style="width:180px"></th>\
							<th                    >Content   <br><button onclick="sortTable(6)">Sort</button><br><input type="text" id="myInput6" onkeyup="myFunction(6)" placeholder="Filter"></th>\
						</tr>\
					</thead>\
					<tbody>';
		let hexes = [];
		let pkt = '';
		let time = '';
		let thread = '';
		let thrdID = '';
		let level = '';
		let io = '';
		let host = '';
		let charac = '';
		let tr_style = '';
		let header = '';
		let body = '';
		let sliced = false;
		let hexes_body = [];
		let chunks = [];
		let next_packet_is_chunk = false;
		let gzip_chunks = [];
		let pkt_len = -1;
		let thread_input = "";
		let thread_filter = false;
		if (document.getElementById('thread-input').value !== "") {
			thread_input = document.getElementById('thread-input').value;
			thread_filter = true;
		}
		let inflated;
		let to_inflate = [];
		let padded_packet = 0;
		let io2;
		let content_gzip=false;
		for (let line = 1; line < lines.length; line++) {
			if (
					(thread_filter && lines[line].includes('|' + thread_input) || !thread_filter) &&
					(lines[line].includes('laintext before ENCRYPTION (') ||
							(lines[line].includes('laintext after DECRYPTION (')
									//&& lines[line - 1].includes('application_data')
							)) &&
					!lines[line - 1].includes('handshake,')
			) {
				time = lines[line].split('|')[4];
				thread = lines[line].split('|')[3];
				thrdID = lines[line].split('|')[2] //.replaceAll(' ', '');
				level = lines[line].split('|')[1];
				if (lines[line].includes('laintext before ENCRYPTION (')) {
					io = 'SENDING';
					io2 = "|WRITE: TLS12 application_data, length = ";
					next_packet_is_chunk = false;
					tr_style = " style='background-color:#000040' ";
				}
				if (lines[line].includes('laintext after DECRYPTION (')) {
					io = 'RECVING';
					io2 = "|READ: TLSv1.2 application_data, length = ";
					tr_style = " style='background-color:#400000' ";
				}
				if (lines[line - 1].includes(io2) && lines[line - 1].includes(thread) && lines[line - 1].includes("|" + thrdID + "|")) {
					pkt_len = lines[line - 1].split(io2)[1];
				} else if (lines[line - 2].includes(io2) && lines[line - 2].includes(thread) && lines[line - 2].includes("|" + thrdID + "|")) {
					pkt_len = lines[line - 2].split(io2)[1];
				} else if (lines[line - 3].includes(io2) && lines[line - 3].includes(thread) && lines[line - 3].includes("|" + thrdID + "|")) {
					pkt_len = lines[line - 3].split(io2)[1];
				} else if (lines[line - 1].includes("WRITE: TLS12 alert(close_notify)")) {
					pkt_len = 0;
					pkt = "TLS12 alert(close_notify)";
				}
				if (lines[line].includes('Padded plaintext')) {
					line++;
					padded_packet = 16;
					//pkt_len = pkt_len - 16;
				}
				line++;
				while (lines[line].length > 3) {
					hexes = hexes.concat(lines[line].substring(8, 57).replaceAll('   ', ' ').split(' '));
					line++;
				}
				if (pkt_len < 0) pkt_len = hexes.length;
				for (let hx = 0; hx < pkt_len; hx++) {
					//test = test.concat(parseInt(hexes[hx], 16));
					switch (hexes[hx]) {
						case '0A':
							charac = '';
							break; // 0A - LF \n
						case '0D':
							charac = '<br>';
							if (!sliced && hexes[hx + 1] === '0A' && hexes[hx + 2] === '0D' && hexes[hx + 3] === '0A') {
								hexes_body = hexes.slice(hx + 4, pkt_len);
								sliced = true;
							}
							break; //0D - CR \r
						case '3C':
							if (hexes[hx + 1] !== '2F') charac = '<br>&lt;'; else charac = '&lt;'; // 2F - /
							break; //3C - <
						case '3E':
							charac = '&gt;';
							break; //3E - >
						default  :
							charac = String.fromCharCode(parseInt(hexes[hx], 16));
					}
					pkt = pkt + charac;
					charac = '';
				}

//////////////////////////////////////////////// hexes to decimal body ////////////////////////////////////////////////////////////////////

				if (next_packet_is_chunk) hexes_body = hexes;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

				if (pkt.startsWith('HTTP') || pkt.startsWith('GET') || pkt.startsWith('POST') || pkt.startsWith('PUT')) {
					header = pkt.split('<br><br>')[0];
					if (header.includes('Content-Encoding: gzip') || header.startsWith('GET')) body = '';
					else body = pkt.split('<br><br>')[1];
				} else {
					header = '';
					if (next_packet_is_chunk) body = '';
					else body = pkt;
				}

				if (header.includes('Server: ')) host = header.split('Server: ')[1].split('<br>')[0];
				if (header.includes('Host: ')) host = header.split('Host: ')[1].split('<br>')[0];
				if (header.includes('Content-Length: 0')) body = '';
				else if (header.includes('Content-Length: ')) body = body.slice(0, parseInt(header.split('Content-Length: ')[1].split('<br>')[0], 10));


				//************ \/\/ Chunks \/\/ ************
				if (header.includes('Content-Encoding: gzip') && !next_packet_is_chunk) {
					content_gzip = true;
				}
				if (header.includes('Transfer-Encoding: chunked') || next_packet_is_chunk) {
					let new_lines = [];
					//find new lines by 0D 0A
					for (let i = 0; i < hexes_body.length; i++) {
						if (hexes_body[i] === "0D" && hexes_body[i + 1] === "0A")
							new_lines = new_lines.concat(i);
					}
					//check if this is has the final chunk 0
					next_packet_is_chunk = !(hexes_body.join('').includes("300D0A0D0A") || (lines[line + 2].includes("WRITE: TLS12 alert(close_notify)") && lines[line + 2].includes("|" + thrdID + "|")));
					//slicing body to chunks
					chunks.push(hexes_body.slice(0, new_lines[0]));
					for (let i = 1; i <= new_lines.length; i++) {
						if (!(padded_packet === 16 && new_lines[i] === undefined)) {
							chunks.push(hexes_body.slice(new_lines[i - 1], new_lines[i]).slice(2));
						}
					}
					//Process the chunks
					if (next_packet_is_chunk) {
						console.log("Skip chunks process, proceeding to the next packet");
						body = 'Chunks decoded in the next packet';
					} else {
						for (let i = 0; i < chunks.length; i++) {
							if (chunks[i] !== "" && chunk_header(chunks[i]) && chunks[i + 1] !== "30" && chunks[i + 2] !== "" && chunks[i + 1] !== undefined && chunks[i + 1].length === chunk_header_length(chunks[i])) {
								gzip_chunks = gzip_chunks.concat(chunks[i + 1]);
								i++;
							}
						}
						chunks = [];
					}
					hexes_body = [];
					//}
					if (next_packet_is_chunk) {
						hexes = hexes_body;
					} else {
						hexes = gzip_chunks;
					}
					if (!next_packet_is_chunk) {
						for (let hx = 0; hx < hexes.length; hx++) {
							to_inflate.push(parseInt(hexes[hx], 16));
						}
						if (content_gzip) {
							try {
								inflated = pako.inflate(new Uint8Array(to_inflate));
							} catch (err) {
								console.error(err);
								console.error("line:", line, "Thread: ", thread, " | hexes: ", hexes);
								console.error("line:", line, "Thread: ", thread, " | to inflate: ", to_inflate);
							}
							try {
								body = "Decoded GZIP: <BR>" + new TextDecoder().decode(inflated).replaceAll('<', '&lt;').replaceAll('>', '&gt;<br>');
							} catch (err) {
								console.error('time: ', time, ' | to decode: ', inflated);
								console.error(err);
							}
							gzip_chunks = [];
							hexes_body = [];
							to_inflate = []
							hexes = [];
							content_gzip = false;
						} else {
							body = "Combined Chunks: <BR>" + to_inflate.map(hex => String.fromCharCode(hex)).join("").replaceAll('<', '&lt;').replaceAll('>', '&gt;<br>'); //.replaceAll('<', '&lt;').replaceAll('>', '&gt;<br>');
						}
					}
				}
				//}
				//************ /\/\ Chunks /\/\ ***********

				//if ((header.includes('Content-Encoding: gzip') && next_packet_is_chunk) && header !== '') pkt = header + '<br>' + body;
				/*else*/
				//if (body.length=0) body="<br><br>"
				if ((header.includes('Content-Encoding: gzip') && next_packet_is_chunk) && header === '') pkt = body;
				else if (header === '') pkt = body;
				else pkt = header + '<br><hr>' + body;
				out = out + '<tr' + tr_style + '>' +
						'<td style="width=3000px">' + time + '</td>' +
						'<td>' + thread + '</td>' +
						'<td>' + thrdID + '</td>' +
						'<td>' + level + '</td>' +
						'<td>' + io + '</td>' +
						'<td>' + host + '</td>' +
						'<td>' + pkt + '</td>' +
						'</tr>\n';
				if (host.length > 0) console.log('Host: ' + host);
				time = '';
				thread = '';
				thrdID = '';
				level = '';
				io = '';
				host = '';
				pkt = '';
				hexes = [];
				sliced = false;
				if (!next_packet_is_chunk) chunks = [];
				header = '';
				body = '';
				hexes_body = [];
				pkt_len = -1;
				padded_packet = 0;
			}
		}
		element.innerHTML = out + "</tbody></table>";
	}
	document.getElementById('file-input').addEventListener('change', readSingleFile, false);

	/** Function that count occurrences of a substring in a string;
	 * @param {String} string               The string
	 * @param {String} subString            The sub string to search for
	 * @param {Boolean} [allowOverlapping]  Optional. (Default:false)
	 *
	 * @author Vitim.us https://gist.github.com/victornpb/7736865
	 * @see Unit Test https://jsfiddle.net/Victornpb/5axuh96u/
	 * @see http://stackoverflow.com/questions/4009756/how-to-count-string-occurrence-in-string/7924240#7924240
	 */
	function occurrences(string, subString, allowOverlapping) {

		string += "";
		subString += "";
		if (subString.length <= 0) return (string.length + 1);

		let n = 0,
				pos = 0,
				step = allowOverlapping ? 1 : subString.length;

		while (true) {
			pos = string.indexOf(subString, pos);
			if (pos >= 0) {
				++n;
				pos += step;
			} else break;
		}
		return n;
	}
	function chunk_header(chunk) {
		const isHere = ["30", "31", "32", "33","34","35","36","37","38","39","61","62","63","64","65","66"];
		return chunk.every(chunkNum => isHere.some(here => chunkNum === here));

	}
	function chunk_header_length(chunk) {
		let str = "";
		if (chunk_header(chunk)) {
			for (let i = 0; i < chunk.length; i++) {
				str += String.fromCharCode(parseInt(chunk[i], 16));
			}
			return parseInt(str, 16);
		} else return null;
	}
</script>
</body> 
</html> 
