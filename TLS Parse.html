<!DOCTYPE HTML>
<html lang="en">
<head>
	<script src="pako.js"></script>
	<style>
		th {
			text-align: center;
			border: 1px solid white;
		}

		td {
			border: 1px solid white;
			word-wrap: break-word;
		}

		table {
			table-layout: fixed;
			width: 100%;
			border: 1px solid white;
			border-collapse: collapse;
			font-family: monospace;
			padding: 2px;
		}
</style>
	<title>Java TLS Debug Log Parser</title>
</head> 

<body style = "text-align:left;background-color:#202020;color:white;" id = "body"> 
<div style="text-align: center;">
	<div id="space"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div>
	<h3>Load your log file:</h3>
	<label for="thread-input">Thread name to decode (ex. sub-scan-0):</label><input id="thread-input"
																					name="thread-input" type="text"><br><br>
	<input id="file-input" type="file"/></div>
<div id="file-content"><p id="afterend"></p></div>
<!-- <pre id="file-content"></pre> -->

<script>


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
    hexes_array=[


	];
    let dec_array=[];

    for (let hx = 0; hx < hexes_array.length; hx++) {
        dec_array = dec_array.concat(parseInt(hexes_array[hx], 16));
    }

    console.log('dec_array.length: ' + dec_array.length);
    console.log("dec_array: " + dec_array);

    //to_inflate = new Uint8Array(dec_array);
    //console.log('to_inflate.length: ' + to_inflate.length);
    //console.log('to_inflate: ' + to_inflate);

    try {
        inflated = pako.inflate(dec_array);
    }
    catch (err) {
        console.error(err);
    }
    decoded = new TextDecoder().decode(inflated);
    console.log('inflated: ' + inflated);
    console.log('decoded: ' + decoded);

*/
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function myFunction(col) {
		// Declare variables
		let input, filter, table, tr, td, i, txtValue;
		input = document.getElementById("myInput" + col);
		filter = input.value.toUpperCase();
		table = document.getElementById("myTable");
		tr = table.getElementsByTagName("tr");

		// Loop through all table rows, and hide those who don't match the search query
		for (i = 0; i < tr.length; i++) {
			td = tr[i].getElementsByTagName("td")[col];
			if (td) {
				txtValue = td.textContent || td.innerText;
				if (txtValue.toUpperCase().indexOf(filter) > -1) {
					tr[i].style.display = "";
				} else {
					tr[i].style.display = "none";
				}
			}
		}
	}

function sortTable(col) {
	let table, rows, switching, i, x, y, shouldSwitch;
	table = document.getElementById("myTable");
  switching = true;
  /*Make a loop that will continue until
  no switching has been done:*/
  while (switching) {
    //start by saying: no switching is done:
    switching = false;
    rows = table.rows;
    /*Loop through all table rows (except the
    first, which contains table headers):*/
    for (i = 1; i < (rows.length - 1); i++) {
      //start by saying there should be no switching:
      shouldSwitch = false;
      /*Get the two elements you want to compare,
      one from current row and one from the next:*/
      x = rows[i].getElementsByTagName("TD")[col];
      y = rows[i + 1].getElementsByTagName("TD")[col];
      //check if the two rows should switch place:
      if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
        //if so, mark as a switch and break the loop:
        shouldSwitch = true;
        break;
      }
    }
    if (shouldSwitch) {
      /*If a switch has been marked, make the switch
      and mark that a switch has been done:*/
      rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
      switching = true;
    }
  }
}

function readSingleFile(e) {
	const file = e.target.files[0];
	if (!file) {return;}
	const reader = new FileReader();
	reader.onload = function(e) {
		const contents = e.target.result.split('\n');
		displayContents(contents);
	};
	reader.readAsText(file);
}

	function displayContents(lines) {
		document.getElementById('space').style.display = "none";
		const element = document.getElementById('file-content');
		let out = '<table id="myTable">\
					<thead>\
						<tr>\
							<th style="width:200px">Time      <br><button onclick="sortTable(0)">Sort</button><br><input type="text" id="myInput0" onkeyup="myFunction(0)" placeholder="Filter" style="width:180px"></th>\
							<th style="width:200px">Thread    <br><button onclick="sortTable(1)">Sort</button><br><input type="text" id="myInput1" onkeyup="myFunction(1)" placeholder="Filter" style="width:180px"></th>\
							<th style="width:50px" >Thrd_ID   <br><button onclick="sortTable(2)">Sort</button><br><input type="text" id="myInput2" onkeyup="myFunction(2)" placeholder="Filter" style="width:40px"></th>\
							<th style="width:50px" >Level     <br><button onclick="sortTable(3)">Sort</button><br><input type="text" id="myInput3" onkeyup="myFunction(3)" placeholder="Filter" style="width:40px"></th>\
							<th style="width:60px" >I/O       <br><button onclick="sortTable(4)">Sort</button><br><input type="text" id="myInput4" onkeyup="myFunction(4)" placeholder="Filter" style="width:50px"></th>\
							<th style="width:200px">Host      <br><button onclick="sortTable(5)">Sort</button><br><input type="text" id="myInput5" onkeyup="myFunction(5)" placeholder="Filter" style="width:180px"></th>\
							<th                    >Content   <br><button onclick="sortTable(6)">Sort</button><br><input type="text" id="myInput6" onkeyup="myFunction(6)" placeholder="Filter"></th>\
						</tr>\
					</thead>\
					<tbody>';
		let hexes = [];
		let pkt = '';
		let time = '';
		let thread = '';
		let thrdID = '';
		let level = '';
		let io = '';
		let host = '';
		let charac = '';
		let tr_style = '';
	let header = '';
		let body = '';
		//const test = [];
		let hexes_body = [];
		let sliced = false;
		let dec_body = [];
		let chunks = [];
		let next_packet_is_chunk = false;
		let gzip_chunks = [];
		let pkt_len = -1;
		let thread_input = "";
		let thread_filter = false;
		if (document.getElementById('thread-input').value !== "") {
			thread_input = document.getElementById('thread-input').value;
			thread_filter = true;
		}
		let inflated;
		let to_inflate;
		for (let line = 1; line < lines.length; line++) {//console.log("r: " + line);
			if (
					(thread_filter && lines[line].includes('|' + thread_input) || !thread_filter) &&
					(lines[line].includes('laintext before ENCRYPTION (') ||
							(lines[line].includes('laintext after DECRYPTION (')
									//&& lines[line - 1].includes('application_data')
							)) &&
					!lines[line - 1].includes('handshake,')
			) {//console.log(line);
				//console.log(time + ' | Aline: ' + line + ' | pkt_len: ' + pkt_len);
				if (lines[line - 1].split("application_data, length = ")[1] > 0)
					pkt_len = lines[line - 1].split("application_data, length = ")[1];
				//console.log(time + ' | Bline: ' + line + ' | pkt_len: ' + pkt_len);
				time = lines[line].split('|')[4];
				thread = lines[line].split('|')[3];
				thrdID = lines[line].split('|')[2].replaceAll(' ', '');
				level = lines[line].split('|')[1];
				if (lines[line].includes('laintext before ENCRYPTION (')) {
					io = 'SENDING';
					tr_style = " style='background-color:#000040' "
				}
				if (lines[line].includes('laintext after DECRYPTION (')) {
					io = 'RECVING';
					tr_style = " style='background-color:#400000' "
				}
				if (lines[line].includes('Padded plaintext')) {
					line++;
					pkt_len = pkt_len - 16;
				}
				line++;
				//console.log('begin packet parse on line '+line);
				while (lines[line].length > 3) {
					hexes = hexes.concat(lines[line].substring(8, 57).replaceAll('   ', ' ').split(' '));
					line++;
				}
				//console.log(time + ' | Cline: ' + line + ' | pkt_len: ' + pkt_len);
				if (pkt_len < 0) pkt_len = hexes.length;
				//console.log('len: '+ (2*hexes.length-pkt_len));
				for (let hx = 0; hx < pkt_len; hx++) {
					//console.log('hx: ' + hx);
					//test = test.concat(parseInt(hexes[hx], 16));
					switch (hexes[hx]) {
						case '0A':
							charac = '';
							break; // 0A - LF \n
						case '0D':
							charac = '<br>';
							if (!sliced && hexes[hx + 1] === '0A' && hexes[hx + 2] === '0D' && hexes[hx + 3] === '0A') {
								hexes_body = hexes.slice(hx + 4, pkt_len);
								//console.log(hexes_body.toString());
								sliced = true;
							}
							break; //0D - CR \r
						case '3C':
							if (hexes[hx + 1] !== '2F') charac = '<br>&lt;'; else charac = '&lt;'; // 2F - /
							break; //3C - <
						case '3E':
							charac = '&gt;';
							break; //3E - >
						default  :
							charac = String.fromCharCode(parseInt(hexes[hx], 16));
					}
					pkt = pkt + charac;
					charac = '';
				}

				//console.log(pkt);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

				if (next_packet_is_chunk) {//console.log("time: " + time + " | pkt_len: " + pkt_len);
					for (let i = 0; i < pkt_len; i++) {
						//console.log("time: " + time + " | if (next_packet_is_chunk) hexes: " + hexes.toString());
						if (hexes[i] !== '' && hexes[i]!==undefined) {
							if (Number.isNaN(parseInt(hexes[i], 16))) console.log("XX: "+hexes[i]);
							dec_body = dec_body.concat(parseInt(hexes[i], 16));
						}
					}
					//console.log('time: ' + time + ' | next_packet_is_chunk: ' + next_packet_is_chunk + ' | dec_body: ' + dec_body);
				} else
					for (let i = 0; i < hexes_body.length; i++) {
						if (hexes_body[i] !== '' && hexes_body[i]!== undefined) {
							if (Number.isNaN(parseInt(hexes_body[i], 16))) console.log("XX: "+hexes_body[i]);
							dec_body = dec_body.concat(parseInt(hexes_body[i], 16));
							}
					}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

				if (pkt.startsWith('HTTP') || pkt.startsWith('GET') || pkt.startsWith('POST') || pkt.startsWith('PUT')) {
					header = pkt.split('<br><br>')[0];
					if (header.includes('Content-Encoding: gzip')) body = '';
					else body = pkt.split('<br><br>')[1];
					//console.log('body: ' + body);
				} else {
					header = '';
					if (next_packet_is_chunk) body = '';
					else body = pkt;
				}

				//pkt = pkt.replaceAll('<br><br>', '<br><hr><br>');
				if (header.includes('Server: ')) host = header.split('Server: ')[1].split('<br>')[0];
				if (header.includes('Host: ')) host = header.split('Host: ')[1].split('<br>')[0];
				if (header.includes('Content-Length: 0')) body = '';
				if (header.includes('Content-Encoding: gzip') || next_packet_is_chunk) {
					//body='';
					if (header.includes('Transfer-Encoding: chunked') || next_packet_is_chunk) {
						//console.log('gzip chunked line: '+line);
						let new_line = [];
						//console.log("xxxxxx: " + dec_body);
						for (let i = 0; i < dec_body.length; i++) {
							if (dec_body[i] === 13 && dec_body[i + 1] === 10)
								new_line = new_line.concat(i);
						}
						//console.log('line: ' + line + ' | new_line length: ' + new_line.length + ' | NLs: ' + new_line + ' | dec_bd_len: ' + dec_body.length);
						//console.log('dec_body: '+dec_body);
						//console.log('new_line[0]: ' + new_line[0]);
						if (new_line.length === 0) { // there was no \r\n in dec_body
							//console.log('mode 1');
							//console.log('1 gzip_chunks: ' + gzip_chunks);
							//console.log('1 dec_body: ' + dec_body);
							gzip_chunks = gzip_chunks.concat(dec_body);
							dec_body = [];
							body = body + '<br>GZIP Chunks decoded in the next packet (1)';
							//console.log('all body data');
						} else if (new_line[0] + 2 === dec_body.length) { // there is a \r\n in the end
							//console.log('mode 2');
							//console.log('2 gzip_chunks: ' + gzip_chunks);
							//console.log('2 dec_body: ' + dec_body.slice(0, new_line[0]));
							gzip_chunks = gzip_chunks.concat(dec_body.slice(0, new_line[0]));
							dec_body = [];
							body = body + '<br>GZIP Chunks decoded in the next packet (2)';
							//console.log('dec_sliced: ' + dec_body.slice(0,new_line[0]) + ' | orig dec: '+ dec_body);
						} else if (new_line.length === 1) { //only one \r\n - probably the chunk ends here
							//console.log('mode 3');
							//console.log('time: ' + time + ' | 3if gzip_chunks: ' + gzip_chunks);
							//console.log('3 dec_body: ' + dec_body.slice(0, new_line[0]));
							chunks[0] = dec_body.slice(0, new_line[0]);
							chunks[1] = dec_body.slice(new_line[0]).slice(2);
							for (let chnk = 0; chnk < chunks.length; chnk++) {
								//console.log('3 chunks[' + chnk + '][0]: ' + String.fromCharCode(chunks[chnk][0]));
								if (chnk % 2 === 0) {
									/*for (let i = 0; i < chunks[chnk].length; i++) {
                                        head = head.concat(chunks[chnk][i]);
                                    }
                                    console.log('line: ' + line + ' | chk_hd: ' + head);
                                    //head = [];
                                    */
									if (String.fromCharCode(chunks[chnk][0]) === '0') {
										next_packet_is_chunk = false;
										//console.log('next_packet_is_chunk is: ' + next_packet_is_chunk + ' | setting to false')
									} else {
										body = body + '<br>GZIP Chunks decoded in the next packet (3)'
										if (next_packet_is_chunk && header.length<1) {
											gzip_chunks = gzip_chunks.concat(chunks[chnk]);
											//console.log("added: " + chunks[chnk]);
										}
										//console.log('next_packet_is_chunk is: ' + next_packet_is_chunk + ' | setting to true');
										next_packet_is_chunk = true;
									}
								} else {
									//console.log('time: ' + time + ' | 3else gzip_chunks: ' + gzip_chunks);
									//console.log('3 chunks[' + chnk + ']: ' + chunks[chnk]);
									gzip_chunks = gzip_chunks.concat(chunks[chnk]);
									//console.log("added: " + chunks[chnk]);
									dec_body = [];
									chunks = [];
								}


							}
							//console.log("mode 3 finish *****************");
						} else {
							//console.log('mode 4 *****************');
							//console.log("4 new_line.length: " + new_line.length);
							//console.log("44444444 new_line[0]: " + new_line[0] + " | new_line[1]: " + new_line[1]);
							//console.log('time: ' + time + ' | 4 gzip_chunks: ' + gzip_chunks);
							//console.log('4 dec_body: ' + dec_body);
							//console.log('4 dec_body.slice: ' + dec_body.slice(0, new_line[0]));
							chunks[0] = dec_body.slice(0, new_line[0]);
							//console.log("4.-1 chunk[0]: " + chunks[0] + " | new_line[0]: " + new_line[0]);
							for (let i = 1; i <= new_line.length; i++) {
								//console.log('4 new_line['+i+']: ' + new_line[i]);
								chunks[i] = dec_body.slice(new_line[i - 1], new_line[i]).slice(2);
								//console.log("4.-1 chunk["+i+"]: " + chunks[i] + " | new_line["+i+"]: " + new_line[i]);
							}
							//console.log('line: ' + line + ' | chunks len: ' + chunks.length);
							//console.log('4 chunks: ' + JSON.stringify(chunks));
							for (let chnk = 0; chnk < chunks.length; chnk++) {
								//console.log('4 line: ' + line + " | chunk["+chnk+"]: " + chunks[chnk] + " | chunks.length: " + chunks.length);
								if (chnk % 2 === 0) {
									//console.log('4 if chnk: ' + chnk);
									//console.log(time + ' line: ' + line + " | 4 next_packet_is_chunk was: " + next_packet_is_chunk + " | chunk: " + chunks[chnk][0]);
									next_packet_is_chunk = ((chunks[chnk][0] !== 48) && chunks[chnk][0] !== undefined); //48 in decimal is 0; i.e. last empty chunk
									if (new_line[0] === 1 && new_line[1] === 3) next_packet_is_chunk = false;
									if (chunks[chnk].length>10) gzip_chunks=gzip_chunks.concat(chunks[chnk]);
									//console.log(time + ' line: ' + line + ' | 4 next_packet_is_chunk now: ' + next_packet_is_chunk);
								} else {
									//console.log('4 else chnk: ' + chnk);
									if (new_line[0] === 1 && new_line[1] === 3) next_packet_is_chunk = false;
									//console.log('4 gzip_chunks: ' + gzip_chunks);
									//console.log('4 else chunks[chnk: ' + chnk + ']: ' + chunks[chnk]);
									//console.log("49999 chunks[" + chnk + "+2]: " + chunks[chnk + 2]);
									if (!(chunks[chnk][0] === 48 &&	(chnk === chunks.length || Number.isNaN(chunks[chnk + 2][0]) || chunks[chnk + 2][0] == undefined || chunks[chnk + 2][0].includes("NaN")))) {
										if (chunks[chnk].length>4) {
											gzip_chunks = gzip_chunks.concat(chunks[chnk]);
											//console.log("4 chunk added: " + chunks[chnk]);
										}
									} else {
										chnk = chunks.length;
										next_packet_is_chunk = false;
									}

								}
								//console.log("4 end for *********");
							}
							dec_body = [];
							chunks = [];
							if (next_packet_is_chunk) body = body + '<br>GZIP Chunks decoded in the next packet (4)'
							//console.log("mode 4 finish *****************");
						}

						if (next_packet_is_chunk) {
							to_inflate = dec_body;
						} else {
							to_inflate = gzip_chunks;
						}

						if (!next_packet_is_chunk) {
							try {
							inflated = pako.inflate(new Uint8Array(to_inflate));
							} catch (err) {
								console.error(err);
								console.error("to inflate: " + to_inflate);
							}
							try {
								body = body + "Decoded GZIP: <BR>" + new TextDecoder().decode(inflated).replaceAll('<', '&lt;').replaceAll('>', '&gt;<br>');
							} catch (err) {
								console.error('time: ' + time + ' | to decode: ' + inflated);
								console.error(err);
							}
							gzip_chunks = [];
							dec_body = [];
						}
					}

			}

			//console.log('line: ' + line + ' | zgip header: ' + header.includes('Content-Encoding: gzip') + ' | nxt_chnk: ' + next_packet_is_chunk + ' | hdr_lg: ' + header.length);
//console.log(body);
			if ((header.includes('Content-Encoding: gzip') && next_packet_is_chunk) || header === '') pkt = header + '<br>' + body;
			else pkt = header + '<br><hr><br>' + body;
			out = out + '<tr' + tr_style + '>' +
					'<td style="width=3000px">' + time + '</td>' +
					'<td>' + thread + '</td>' +
					'<td>' + thrdID + '</td>' +
					'<td>' + level + '</td>' +
					'<td>' + io + '</td>' +
					'<td>' + host + '</td>' +
					'<td>' + pkt + '</td>' +
					'</tr>\n';
			if (host.length > 0) console.log('Host: ' + host);
			time = '';
			thread = '';
			thrdID = '';
			level = '';
			io = '';
			host = '';
			pkt = '';
			hexes = [];
			sliced = false;
			chunks = [];
			header = '';
			body = '';
			dec_body = [];
			pkt_len = -1;
		}
			//next_packet_is_chunk=false;
		}
	element.innerHTML = out + "</tbody></table>";
}

	document.getElementById('file-input').addEventListener('change', readSingleFile, false);


	/** Function that count occurrences of a substring in a string;
	 * @param {String} string               The string
	 * @param {String} subString            The sub string to search for
	 * @param {Boolean} [allowOverlapping]  Optional. (Default:false)
	 *
	 * @author Vitim.us https://gist.github.com/victornpb/7736865
	 * @see Unit Test https://jsfiddle.net/Victornpb/5axuh96u/
	 * @see http://stackoverflow.com/questions/4009756/how-to-count-string-occurrence-in-string/7924240#7924240
	 */
	function occurrences(string, subString, allowOverlapping) {

		string += "";
		subString += "";
		if (subString.length <= 0) return (string.length + 1);

		let n = 0,
				pos = 0,
				step = allowOverlapping ? 1 : subString.length;

		while (true) {
			pos = string.indexOf(subString, pos);
			if (pos >= 0) {
				++n;
				pos += step;
			} else break;
		}
		return n;
	}
</script>
</body> 
</html> 
